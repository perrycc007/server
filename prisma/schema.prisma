generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

enum CheckStatus {
  NOT_YET_CHECKED
  CHECKING
  CHECKED
}

enum MatchStatus {
  REJECTED
  ASK_AGAIN
  NO_LONGER_MATCH
  OPEN
}

enum Day {
  MON
  TUE
  WED
  THU
  FRI
  SAT
  SUN
}

enum ExamType {
  HKDSE
  HKCEE
  IB
  HKALE
  GCEALevel
  IGCSE
}

enum Area {
  LIBERAL_ARTS
  SCIENCE
  BUSINESS
  CORE_SUBJECTS
  ELECTIVE_SUBJECTS
  OTHER_LANGUAGE_SUBJECTS
  LANGUAGES
  MATHEMATICS
  HUMANITIES_AND_SOCIAL_SCIENCES
  CREATIVE_TECHNICAL_AND_VOCATIONAL
}

enum Role{
  USER
  ADMIN
}

model profile {
  idprofile             Int       @id @default(autoincrement())
  userid                Int       @unique
  availtime             String?   @db.VarChar(600)
  address               String?   @db.VarChar(45)
  agreewith             String?   @db.VarChar(45)
  country               String?   @db.VarChar(45)
  emergencycontact      String?   @db.VarChar(45)
  emergencyphone        String?   @db.VarChar(45)
  emergencyrelationship String?   @db.VarChar(45)
  findus                String?   @db.VarChar(45)
  language              String?   @db.VarChar(45)
  name                  String?   @db.VarChar(45)
  nationality           String?   @db.VarChar(45)
  phoneno               String?   @db.VarChar(45)
  lastOnline            DateTime? @db.DateTime(0)
  user                  user      @relation(fields: [userid], references: [userid])
}

model user {
  userid           Int         @id @default(autoincrement())
  email            String      @unique @db.VarChar(45)
  password         String      @db.TinyText
  favouritecaseid  Json?
  favouritetutorid Json?
  role             Role        @default(USER)
  profile          profile?
  tutor            tutor?
  students         student[]
  favourites       favourite[]

}

model favourite {
  idfavourite Int     @id @default(autoincrement())
  userid      Int
  studentid   Int // Student ID
  tutorid     Int // Tutor ID
  user        user    @relation(fields: [userid], references: [userid])
  student     student @relation(fields: [studentid], references: [studentid])
  tutor       tutor   @relation(fields: [tutorid], references: [tutorid])
}

model student {
  studentid         Int                @id @default(autoincrement())
  userid            Int
  lowestfrequency   Int?
  lowestfee         Int?
  lowestduration    Int?
  language          String?            @db.VarChar(45)
  others            String?            @db.VarChar(45)
  expectation       String?            @db.VarChar(45)
  genderrequirement String?            @db.VarChar(45)
  status            String?            @db.VarChar(45)
  highestfee        Int?
  highestfrequency  Int?
  highestduration   Int?
  level             String?            @db.VarChar(45)
  lastOnline        DateTime?          @db.DateTime(0)
  matches           match[] // Back-relation for matches
  user              user               @relation(fields: [userid], references: [userid])
  favourites        favourite[] // Add this line
  studentLocation   studentLocation[]
  studentSubjects   StudentSubject[]
  StudentAvailTime  StudentAvailTime[]
  completeFormStatus Boolean          @default(false)
}

model tutor {
  tutorid              Int              @id @default(autoincrement())
  userid               Int?             @unique
  intro                String?          @db.VarChar(45)
  language             String?          @db.VarChar(45)
  occupation           String?          @db.VarChar(45)
  secondaryschool      String?          @db.VarChar(45)
  primaryschool        String?          @db.VarChar(45)
  yearofexperience     String?          @db.VarChar(45)
  experience           String?          @db.VarChar(45)
  highestteachinglevel String?          @db.VarChar(45)
  educationallevel     String?          @db.VarChar(45)
  notes                String?          @db.VarChar(45)
  schoolcat            String?          @db.VarChar(45)
  year                 String?          @db.VarChar(45)
  publicexamgrade      String?          @db.VarChar(45)
  university           String?          @db.VarChar(45)
  othercert            String?          @db.VarChar(45)
  caseid               String?          @db.VarChar(45)
  major                String?          @db.VarChar(45)
  subgrade             Json?
  strength             String?          @db.VarChar(45)
  highestfee           Int?
  lowestfee            Int?
  matchedbefore        Json?
  status               String?          @default("open") @db.VarChar(45)
  lastOnline           DateTime?        @db.DateTime(0)
  verify               String?          @default("未驗證") @db.VarChar(45)
  completeFormStatus Boolean          @default(false)
  user                 user?            @relation(fields: [userid], references: [userid])
  matches              match[] // Back-relation for matches
  favourites           favourite[] // Add this line
  tutorLocation        tutorLocation[]
  tutorGrades          TutorGrade[]
  tutorAvailTimes      TutorAvailTime[]
  tutorSubjects        TutorSubject[]
}

model match {
  idmatch      Int         @id @default(autoincrement())
  studentid    Int // Student ID
  tutorid      Int // Tutor ID
  availability Boolean // Indicates availability for the match
  checkStatus  CheckStatus // Status of the check
  student      student     @relation(fields: [studentid], references: [studentid])
  tutor        tutor       @relation(fields: [tutorid], references: [tutorid])
  matchstatus  MatchStatus
}

model location {
  locationId       Int               @id @default(autoincrement())
  region           String?
  location         String?
  tutorLocations   tutorLocation[]
  studentLocations studentLocation[]
}

model tutorLocation {
  tutorId    Int
  locationId Int
  tutor      tutor    @relation(fields: [tutorId], references: [tutorid])
  location   location @relation(fields: [locationId], references: [locationId])

  @@id([tutorId, locationId]) // Composite primary key
}

model studentLocation {
  studentid  Int
  locationId Int
  student    student  @relation(fields: [studentid], references: [studentid])
  location   location @relation(fields: [locationId], references: [locationId])

  @@id([studentid, locationId]) // Composite primary key
}

model Subject {
  subjectId       Int              @id @default(autoincrement())
  name            String?
  category        String?
  tutorSubjects   TutorSubject[]
  studentSubjects StudentSubject[]
}

model TutorSubject {
  tutorId   Int
  subjectId Int
  tutor     tutor   @relation(fields: [tutorId], references: [tutorid])
  subject   Subject @relation(fields: [subjectId], references: [subjectId])

  @@id([tutorId, subjectId]) // Composite primary key
}

model StudentSubject {
  studentId Int
  subjectId Int
  student   student @relation(fields: [studentId], references: [studentid])
  subject   Subject @relation(fields: [subjectId], references: [subjectId])

  @@id([studentId, subjectId]) // Composite primary key
}

model Grade {
  id          Int          @id @default(autoincrement())
  examtype    ExamType
  area        Area
  subject     String?
  tutorGrades TutorGrade[]
}

model TutorGrade {
  tutorId Int
  gradeId Int
  examGrade  String?
  tutor   tutor @relation(fields: [tutorId], references: [tutorid])
  grade   Grade @relation(fields: [gradeId], references: [id])

  @@id([tutorId, gradeId]) // Composite primary key
}

model AvailTime {
  id                Int                @id @default(autoincrement())
  day               Day
  time              String
  tutorAvailTimes   TutorAvailTime[]
  studentAvailTimes StudentAvailTime[]

}

model TutorAvailTime {
  tutorId     Int
  availTimeId Int
  tutor       tutor     @relation(fields: [tutorId], references: [tutorid])
  availTime   AvailTime @relation(fields: [availTimeId], references: [id])

  @@id([tutorId, availTimeId]) // Composite primary key
}

model StudentAvailTime {
  studentId   Int
  availTimeId Int
  student     student   @relation(fields: [studentId], references: [studentid])
  availTime   AvailTime @relation(fields: [availTimeId], references: [id])

  @@id([studentId, availTimeId]) // Composite primary key
}
